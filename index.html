<html>
    <head>
        <title>Scrumptious Produce - A Scrum Game</title>
    </head>
    <body>
        <h1 style="text-align: center; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Scrumptious Produce</h1>
        <section style="height: 800px; width: 800px; margin-left: auto; margin-right: auto; padding: 10px 10px 10px 10px;">
            <canvas id="game" height="800px" width="800px" style="border: 1px solid black">
                If you're seeing this, your browser doesn't support the canvas element. Please apply updates or switch browsers to use Scrumptious Produce.
            </canvas>
        </section>
        <script type="text/javascript">
            const DEBUG = false;
            const DEBUG_LOGGING = true;
            const TRACE_LOGGING = false;

            // These have to be classic functions to access the arguments object
            function debugLog() {
                if (!DEBUG_LOGGING) {
                    return;
                }

                console.log.apply(console, arguments);
            };

            function traceLog() {
                if (!TRACE_LOGGING) {
                    return;
                }

                console.log.apply(console, arguments);
            }

            const CANVAS_HEIGHT = 800;
            const CANVAS_WIDTH = 800;

            const GLOBAL_STATE = {
                ELEMENT_HOVERED: false,
                HELP_DISPLAYED: false,
            };

            const HEADER_COLOR = "rgb(11,133,0)";
            const HEADER_HEIGHT = 85;

            const FOOTER_COLOR = "rgb(11,133,0)";
            const FOOTER_HEIGHT = 50;

            const BUTTON_TEXTS = ["New Game", "Save Game", "Help", "The Scrum Guide"];
            const BUTTON_CLICKS = {
                "NEW_GAME": () => { console.log("New game clicked!"); },
                "SAVE_GAME": () => { console.log("Save game clicked!"); },
                "HELP": () => { GLOBAL_STATE.HELP_DISPLAYED = true; console.log("Help clicked!"); GLOBAL_STATE.HELP_DISPLAYED = false },
                "THE_SCRUM_GUIDE": () => window.open("https://scrumguides.org/scrum-guide.html", "_blank")
            };

            const BUTTON_HOVERS = {};
            const BUTTONS_BORDER_COLOR = "rgb(255,0,0)";
            const BUTTONS_COLOR = "rgb(0,0,0)";
            const BUTTONS_FONT = "28px sans-serif";
            const BUTTONS_LEFT_MARGIN = 25;
            const BUTTONS_TOP_MARGIN = 55;
            const BUTTON_HORIZONTAL_MARGIN = 60;
            const BUTTON_PROPERTIES = {};   

            const getButtonName = text => text.split(" ").map(word => word.toUpperCase()).join("_");
            const getButtonHeight = measurements => measurements.actualBoundingBoxDescent + measurements.actualBoundingBoxAscent;
            const getButtonWidth = measurements => Math.round(measurements.actualBoundingBoxRight + measurements.actualBoundingBoxLeft);
            const getButtonDimensions = (context, text) => {
                const measurements = context.measureText(text);
                return [ getButtonHeight(measurements), getButtonWidth(measurements), measurements ];
            };

            const BACKGROUND_COLOR = "rgb(100, 100, 100)";
            const BACKGROUND_HEIGHT = CANVAS_HEIGHT - (HEADER_HEIGHT + FOOTER_HEIGHT);
            const BACKGROUND_WIDTH = CANVAS_WIDTH;

            // TODO: Replace with image or at least some cooler canvas drawing
            const CHARACTER_SKIN_COLOR = "rgb(210, 180, 140, 1)";
            const CHARACTER_ACCELERATION = 1;
            const CHARACTER_FRICTION = 0.1;
            const CHARACTER_MAX_VELOCITY = 10;
            const CHARACTER_MIN_VELOCITY = -10;
            const CHARACTER_HEIGHT = 50;
            const CHARACTER_WIDTH = 50;
            const CHARACTER_FACE_WIDTH_RADIUS = 25;
            const CHARACTER_FACE_HEIGHT_RADIUS = 30;
            const CHARACTER_RADIUS = CHARACTER_WIDTH / 2;
            const CHARACTER_POSITION = {
                x: BACKGROUND_WIDTH / 2 - CHARACTER_WIDTH / 2,
                y: (HEADER_HEIGHT + (BACKGROUND_HEIGHT / 2)) - CHARACTER_HEIGHT / 2,
                x2: this.x + CHARACTER_WIDTH,
                y2: this.y + CHARACTER_HEIGHT,
                getMidpoint: function() { 
                    const x = this.x + ((this.x2 - this.x) / 2);
                    const y = this.y + ((this.y2 - this.y) / 2);

                    return { x, y };
                },
                update: function({ x, y }) {
                    if (this.x !== x) {
                        this.x = x;
                        this.x2 = this.x + CHARACTER_WIDTH;
                    }
                    
                    if (this.y !== y) {
                        this.y = y;
                        this.y2 = this.y + CHARACTER_HEIGHT;
                    }
                }
            };
            const CHARACTER_POSITION_BOUNDARY = {
                x: {
                    floor: 0,
                    ceiling: BACKGROUND_WIDTH - CHARACTER_WIDTH,
                    boundsViolation: function(value) { value <= this.floor ? "floor" : value >= this.ceiling ? "ceiling" : undefined },
                    inBounds: function(value) { return value > this.floor && value < this.ceiling }
                },
                y: {
                    floor: HEADER_HEIGHT,
                    ceiling: (HEADER_HEIGHT + BACKGROUND_HEIGHT) - CHARACTER_HEIGHT,
                    boundsViolation: function(value) { value <= this.floor ? "floor" : value >= this.ceiling ? "ceiling" : undefined },
                    inBounds: function(value) { return value > this.floor && value < this.ceiling }
                }
            };

            const CHARACTER_EYE_WIDTH = 9;
            const CHARACTER_EYE_MARGIN = CHARACTER_EYE_WIDTH / 2;
            // const CHARACTER_EYE_MARGIN = 9;
            const CHARACTER_EYE_BACKGROUND_COLOR = "rgb(255, 255, 255)";
            const CHARACTER_IRIS_COLOR = "gray";
            const CHARACTER_PUPIL_COLOR = "rgb(0, 0, 0)";
            const CHARACTER_PUPIL_WIDTH = 3;
            const CHARACTER_PUPIL_OFFSET = Math.floor(CHARACTER_EYE_WIDTH / 2 - CHARACTER_PUPIL_WIDTH / 2);

            const CHARACTER_VELOCITY = {
                x: 0,
                y: 0,
                update: function({ x, y }) {
                    if (this.x !== x) {
                        this.x = x;
                    }

                    if (this.y !== y) {
                        this.y = y;
                    }
                }
            };

            const velocityLessThanFriction = (velocity, friction) => {
                return (velocity > 0 && velocity < friction) ||
                       (velocity < 0 && Math.abs(velocity) < friction);
            };

            const getNext = (current, change, bound, boundType = "ceiling") => {
                const summed = current + change;

                const wouldViolateBounds = boundType === "ceiling" ? summed > bound : summed < bound;
                const next = wouldViolateBounds ? bound : summed;

                return [ wouldViolateBounds, next ];
            };

            const getNextCeiling = (current, change, bound) => getNext(current, change, bound, "ceiling");
            const getNextFloor = (current, change, bound) => getNext(current, change, bound, "floor");

            const getNextXPosition = (currentPosition, velocity) => {
                if (velocity === 0) {
                    return [ false, currentPosition ];
                }

                if (velocity > 0) {
                    return getNextCeiling(currentPosition, velocity, CHARACTER_POSITION_BOUNDARY.x.ceiling);
                } else {
                    return getNextFloor(currentPosition, velocity, CHARACTER_POSITION_BOUNDARY.x.floor);
                }
            };
            const getNextYPosition = (currentPosition, velocity) => {
                if (velocity === 0) {
                    return [ false, currentPosition ];
                }

                if (velocity > 0) {
                    return getNextCeiling(currentPosition, velocity, CHARACTER_POSITION_BOUNDARY.y.ceiling);
                } else {
                    return getNextFloor(currentPosition, velocity, CHARACTER_POSITION_BOUNDARY.y.floor);
                }
            };

            const getNextVelocity = (currentVelocity, friction, wouldViolateBounds) => {
                if (currentVelocity === 0 || wouldViolateBounds || velocityLessThanFriction(currentVelocity, friction)) {
                    return 0;
                }

                if (currentVelocity > 0) {
                    return currentVelocity - friction;
                } else {
                    return currentVelocity + friction;
                }
            };

            const getNextVelocities = (velocities, violations, friction) => {
                return [
                    getNextVelocity(velocities.x, friction, violations.x),
                    getNextVelocity(velocities.y, friction, violations.y)
                ];
            };

            const updateCharacter = (positions, velocities) => {
                if (velocities.x === 0 && velocities.y === 0) {
                    return;
                }

                const [ xWouldViolate, x ] = getNextXPosition(positions.x, velocities.x);
                const [ yWouldViolate, y ] = getNextYPosition(positions.y, velocities.y);
                const violations = { x: xWouldViolate, y: yWouldViolate };
                const [ xVelocity, yVelocity ] = getNextVelocities(velocities, violations, CHARACTER_FRICTION);

                positions.update({ x, y });
                velocities.update({ x: xVelocity, y: yVelocity });
            };

            const canvas = document.querySelector("#game");
            const context = canvas.getContext("2d");

            const doAndRestore = (drawFunction) => {
                context.save();
                drawFunction(context);
                context.restore();
            };

            const generateButtonPosition = (context, text, x, y) => {
                let height, width, measurements;       

                doAndRestore(context => {
                    context.font = BUTTONS_FONT;
                    [height, width, measurements] = getButtonDimensions(context, text);
                    debugLog(`Height of ${text}: ${height}`);
                    debugLog(`Width of ${text}: ${width}`);
                    debugLog("Measurements of " + text + ":", measurements);
                });

                return {
                    x,
                    y: y - measurements.actualBoundingBoxAscent,
                    x2: x + width,
                    y2: y + measurements.actualBoundingBoxDescent,
                    height,
                    width
                };
            };

            const createButton = (context, text, x, y) => {
                debugLog("Creating a button with text: " + text + ", x: " + x + ", y: " + y);
                const name = getButtonName(text);
                const position = generateButtonPosition(context, text, x, y);
                const textWidth = position.width;

                const properties = {
                    hovered: false,
                    position,
                    text
                };

                if (BUTTON_CLICKS[name]) {
                    properties.onClick = BUTTON_CLICKS[name];
                }

                if (BUTTON_HOVERS[name]) {
                    properties.onHover = BUTTON_HOVERS[name];
                }

                BUTTON_PROPERTIES[name] = properties;

                return textWidth;
            };                     

            let nextX = BUTTONS_LEFT_MARGIN;
            for (const text of BUTTON_TEXTS) {
                const buttonWidth = createButton(context, text, nextX, BUTTONS_TOP_MARGIN);
                nextX += (buttonWidth + BUTTON_HORIZONTAL_MARGIN);
            }

            const drawButton = (context, buttonProperties) => {
                const { text, position, hovered, onHover = undefined } = buttonProperties;
                const { x, x2, y, y2, height, width } = position;

                doAndRestore(context => {                    
                    context.font = BUTTONS_FONT;
                    context.fillStyle = BUTTONS_COLOR;
                    // Seems like a hack for a bug I can't suss out regarding text position
                    context.textBaseline = "hanging";
                    context.fillText(text, x, y);
                });

                if (DEBUG) {
                    doAndRestore(context => {
                        context.strokeStyle = BUTTONS_BORDER_COLOR;
                        context.strokeRect(x, y, width, height);
                    });
                }

                if (hovered) {                    
                    doAndRestore(context => {
                        context.lineWidth = 1;
                        context.strokeStyle = "rgb(0,0,0)";
                        context.beginPath();
                        context.moveTo(x, y2);
                        context.lineTo(x2, y2);
                        context.stroke();
                    });

                    if (onHover) {
                        onHover();
                    }
                }
            };

            const getCanvasPosition = (canvas, event) => {
                const { left, top } = canvas.getBoundingClientRect();
                const { clientX, clientY } = event;

                return [ clientX - left, clientY - top ];
            };

            const within = (value, minimum, maximum) => value >= minimum && value <= maximum;
            const withinButtonCoordinates = (x, y, button) => {
                return within(x, button.position.x, button.position.x2) &&
                       within(y, button.position.y, button.position.y2);
            };

            canvas.addEventListener("click", event => {
                const [x, y] = getCanvasPosition(canvas, event);
                traceLog("Mouse clicked at x: " + x + ", y: " + y + " in canvas");
                const clickedButton = Object.values(BUTTON_PROPERTIES)
                                            .find(button => withinButtonCoordinates(x, y, button));

                if (clickedButton) {
                    debugLog("Coordinates click hit:", clickedButton);
                    clickedButton.onClick();
                } else {
                    debugLog("Coordinates click miss");
                }
            });

            let hoveredButton = undefined;
            let lastHoveredButton = undefined;

            document.addEventListener("keydown", event => {
                let { x, y } = CHARACTER_VELOCITY;

                switch (event.which) {
                    // LEFT
                    case 37:
                        if (x > 0) {
                            x = -CHARACTER_ACCELERATION;
                        } else {
                            x = Math.max(x - CHARACTER_ACCELERATION, CHARACTER_MIN_VELOCITY);
                        }
                        break;

                    // UP
                    case 38:
                        if (y > 0) {
                            y = -CHARACTER_ACCELERATION;
                        } else {                            
                            y = Math.max(y - CHARACTER_ACCELERATION, CHARACTER_MIN_VELOCITY);
                        }
                        break;

                    // RIGHT
                    case 39:
                        if (x < 0) {
                            x = CHARACTER_ACCELERATION;
                        } else {                            
                            x = Math.min(x + CHARACTER_ACCELERATION, CHARACTER_MAX_VELOCITY);
                        }
                        break;

                    // DOWN
                    case 40:
                        if (y < 0) {
                            y = CHARACTER_ACCELERATION;
                        } else {
                            y = Math.min(y + CHARACTER_ACCELERATION, CHARACTER_MAX_VELOCITY);
                        }
                        
                        break;

                    default:
                        return;
                }                

                CHARACTER_VELOCITY.update({ x, y });
                event.preventDefault();
            });

            document.querySelector("body").addEventListener("mousemove", event => {
                if (event.target.id === "canvas") {
                    return;
                }

                if (event.target.localName === "body") {
                    GLOBAL_STATE.ELEMENT_HOVERED = false;
                    if (lastHoveredButton) {
                        lastHoveredButton.hovered = false;
                    }
                }
            });

            canvas.addEventListener("mousemove", event => {
                const [x, y] = getCanvasPosition(canvas, event);
                traceLog("Mouse at x: " + x + ", y: " + y + " in canvas");

                lastHoveredButton = hoveredButton;
                hoveredButton = Object.values(BUTTON_PROPERTIES)
                                      .find(button => withinButtonCoordinates(x, y, button));

                
                if (hoveredButton) {                    
                    traceLog("Coordinates hover hit:", hoveredButton);
                    GLOBAL_STATE.ELEMENT_HOVERED = true;
                    hoveredButton.hovered = true;
                    if (hoveredButton.onHover) {
                        hoveredButton.onHover();
                    }
                } else {
                    traceLog("Coordinates hover miss");
                    GLOBAL_STATE.ELEMENT_HOVERED = false;
                    if (lastHoveredButton) {
                        lastHoveredButton.hovered = false;
                    }
                }
            });            
            
            const clearHoverCursor = () => document.body.style.cursor = "default";
            const setHoverCursor = () => document.body.style.cursor = "pointer";

            // Update states for single frame passage
            const step = () => {
                updateCharacter(CHARACTER_POSITION, CHARACTER_VELOCITY);
            };

            const DESIRED_FPS = 60;
            const FRAME_DURATION = 1000 / DESIRED_FPS;

            let start = document.timeline.currentTime;
            let elapsed = 0;
            let accumulated = 0;

            const loop = now => {
                traceLog("Game loop execution");
                elapsed = now - start;
                start = now;

                accumulated += elapsed;

                while (accumulated >= FRAME_DURATION) {
                    step();
                    accumulated -= FRAME_DURATION;
                }
            };

            const drawBackground = () => {
                doAndRestore(context => {
                    context.fillStyle = BACKGROUND_COLOR;
                    context.fillRect(0, HEADER_HEIGHT, BACKGROUND_WIDTH, BACKGROUND_HEIGHT);
                });
            };

            const drawFace = (context, x, y, width, height) => {                
                traceLog("Drawing character head at x: " + x + ", y: " + y);
                context.fillStyle = CHARACTER_SKIN_COLOR;
                context.beginPath();
                context.ellipse(x, y, width, height, 0, 0, 2 * Math.PI);
                context.fill();
            };

            const drawHair = (context, x, y, width, height) => {

            };

            const drawEyebrow = (context, x, y) => {
                context.strokeStyle = "black";
                context.beginPath();
                context.arc(x, y - CHARACTER_EYE_WIDTH * .1, CHARACTER_EYE_WIDTH * .7, -.25 * Math.PI, -.75 * Math.PI, true);
                context.stroke();
            };

            const drawEyelid = (context, x, y) => {
                context.beginPath();
                context.arc(x, y, CHARACTER_EYE_WIDTH * .6, -.25 * Math.PI, -.75 * Math.PI, true);
                context.fillStyle = CHARACTER_SKIN_COLOR;
                context.fill();
                context.strokeStyle = "pink";
                context.stroke();
            };

            const drawIris = (context, x, y) => {
                context.beginPath();
                context.arc(x, y, CHARACTER_EYE_WIDTH * .4, 0, 2 * Math.PI, false);
                context.fillStyle = CHARACTER_IRIS_COLOR;
                context.fill();
            };

            const drawPupil = (context, x, y) => {
                context.beginPath();
                context.arc(x, y, CHARACTER_EYE_WIDTH / 5, 0, 2 * Math.PI, false);
                context.fillStyle = CHARACTER_PUPIL_COLOR;
                context.fill();
            };

            const drawSclera = (context, x, y) => {
                context.beginPath();
                context.arc(x, y, CHARACTER_EYE_WIDTH * .6, 0, 2 * Math.PI, false);
                context.fillStyle = CHARACTER_EYE_BACKGROUND_COLOR;
                context.fill();
                context.strokeStyle = "pink";
                context.stroke();
            };

            const drawEye = (context, x, y, xTranslate = -CHARACTER_EYE_WIDTH * .9, yTranslate = -CHARACTER_EYE_WIDTH * .9) => {
                doAndRestore(context => {
                    context.lineWidth = 1;
                    context.translate(xTranslate, yTranslate);

                    drawSclera(context, x, y);
                    drawIris(context, x, y);
                    drawPupil(context, x, y);
                    drawEyelid(context, x, y);
                    drawEyebrow(context, x, y);
                });                
            };

            const drawNose = (context, x, y, xTranslate = 0, yTranslate = 0) => {
                doAndRestore(context => {
                    context.translate(xTranslate, yTranslate);
                    context.beginPath();
                    context.arc(x, y, 4, 0, 2 * Math.PI, false);
                    context.strokeStyle = "pink";
                    context.stroke();

                    context.beginPath();
                    context.arc(x, y, 2, 0, 2 * Math.PI, false);
                    /*
                    context.moveTo(x - 2, y);
                    context.lineTo(x - 3, y + 3);
                    context.lineTo(x - 6, y + 6);

                    context.lineTo(x + 6, y + 6);
                    context.lineTo(x + 3, y + 3);
                    context.lineTo(x + 2, y);

                    context.lineTo(x - 2, y);
                    */
                    context.fillStyle = "brown";
                    context.fill();
                });
            };

            const drawMouth = (context, x, y, width) => {                
                context.beginPath();
                context.arc(x, y, width, 0, Math.PI, false);
                context.strokeStyle = "pink";
                context.stroke();
            };

            const drawHead = (x, y) => {
                drawFace(context, x, y, CHARACTER_FACE_WIDTH_RADIUS, CHARACTER_FACE_HEIGHT_RADIUS);
                drawHair(context, x, y, CHARACTER_FACE_WIDTH_RADIUS * 2, 10);
                drawEye(context, x, y, -CHARACTER_EYE_WIDTH * .9, -CHARACTER_EYE_WIDTH * .9);
                drawEye(context, x, y, CHARACTER_EYE_WIDTH * .9, -CHARACTER_EYE_WIDTH * .9);
                drawNose(context, x, y, 0, 5);
                drawMouth(context, x, y + CHARACTER_HEIGHT * .1, CHARACTER_WIDTH / 3);
            };

            const drawCharacter = () => {
                const { x, y } = CHARACTER_POSITION;
                drawHead(x, y);
            };

            const drawHeader = () => {
                // Header
                doAndRestore(context => {
                    context.fillStyle = HEADER_COLOR;
                    context.fillRect(0, 0, CANVAS_WIDTH, HEADER_HEIGHT);   
                });

                // Header buttons, each drawButton will also call doAndRestore
                for (const button of Object.values(BUTTON_PROPERTIES)) {
                    drawButton(context, button);
                }
            };

            const drawFooter = () => {                
                doAndRestore(context => {
                    context.fillStyle = FOOTER_COLOR;
                    context.fillRect(0, CANVAS_HEIGHT - FOOTER_HEIGHT, CANVAS_WIDTH, FOOTER_HEIGHT);
                });
            }

            const draw = () => {
                context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                drawBackground();
                drawHeader();
                drawCharacter();                
                drawFooter();

                if (GLOBAL_STATE.ELEMENT_HOVERED) {
                    setHoverCursor();
                } else {
                    clearHoverCursor();
                }

                window.requestAnimationFrame(draw);
            };

            window.requestAnimationFrame(draw);
            window.setInterval(() => loop(document.timeline.currentTime), FRAME_DURATION);
        </script>
    </body>
</html>